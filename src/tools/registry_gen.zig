const std = @import("std");
const manifest_mod = @import("manifest.zig");
const fingerprint = @import("registry_fingerprint.zig");

const EntryOut = struct {
    tool_name: []const u8,
    schema_fingerprint_hex: []const u8,
    requires_network: bool,
    native: bool,
};

pub fn main(init: std.process.Init) !void {
    const a = init.gpa;
    const io = init.io;
    const argv = try init.minimal.args.toSlice(init.arena.allocator());

    const plugin_dir = flagValue(argv, "--plugin-dir") orelse "plugins";
    const out_path = flagValue(argv, "--out") orelse "src/tools/registry_generated.zig";

    var entries = std.array_list.Managed(EntryOut).init(a);
    defer {
        for (entries.items) |entry| {
            a.free(entry.tool_name);
            a.free(entry.schema_fingerprint_hex);
        }
        entries.deinit();
    }

    var plugins = try std.Io.Dir.cwd().openDir(io, plugin_dir, .{});
    defer plugins.close(io);

    var it = plugins.iterate();
    while (try it.next(io)) |ent| {
        if (ent.kind != .directory) continue;
        if (ent.name.len == 0) continue;
        if (ent.name[0] == '.') continue;

        const manifest_path = try std.fmt.allocPrint(a, "{s}/{s}/tool.toml", .{ plugin_dir, ent.name });
        defer a.free(manifest_path);

        var owned = manifest_mod.loadManifest(a, io, manifest_path) catch |err| switch (err) {
            error.FileNotFound => continue,
            else => return err,
        };
        defer owned.deinit(a);

        const fp = try fingerprint.schemaFingerprintHexAlloc(a, owned.manifest.args);

        try entries.append(.{
            .tool_name = try a.dupe(u8, owned.manifest.tool_name),
            .schema_fingerprint_hex = fp,
            .requires_network = owned.manifest.requires_network,
            .native = owned.manifest.native,
        });
    }

    std.sort.block(EntryOut, entries.items, {}, struct {
        fn lessThan(_: void, a_: EntryOut, b_: EntryOut) bool {
            return std.mem.lessThan(u8, a_.tool_name, b_.tool_name);
        }
    }.lessThan);

    var file = try std.Io.Dir.cwd().createFile(io, out_path, .{ .truncate = true });
    defer file.close(io);

    var wbuf: [4096]u8 = undefined;
    var writer = file.writer(io, &wbuf);

    try writer.interface.writeAll("// AUTO-GENERATED by src/tools/registry_gen.zig. Do not edit manually.\n\n");
    try writer.interface.writeAll("pub const Entry = struct {\n");
    try writer.interface.writeAll("    tool_id: usize,\n");
    try writer.interface.writeAll("    tool_name: []const u8,\n");
    try writer.interface.writeAll("    schema_fingerprint_hex: []const u8,\n");
    try writer.interface.writeAll("    requires_network: bool,\n");
    try writer.interface.writeAll("    native: bool,\n");
    try writer.interface.writeAll("};\n\n");
    try writer.interface.writeAll("pub const entries = [_]Entry{\n");

    for (entries.items, 0..) |entry, i| {
        try writer.interface.print(
            "    .{{ .tool_id = {d}, .tool_name = \"{s}\", .schema_fingerprint_hex = \"{s}\", .requires_network = {s}, .native = {s} }},\n",
            .{
                i + 1,
                entry.tool_name,
                entry.schema_fingerprint_hex,
                if (entry.requires_network) "true" else "false",
                if (entry.native) "true" else "false",
            },
        );
    }

    try writer.interface.writeAll("};\n");
    try writer.flush();
}

fn flagValue(argv: []const [:0]const u8, name: []const u8) ?[]const u8 {
    var i: usize = 0;
    while (i + 1 < argv.len) : (i += 1) {
        if (std.mem.eql(u8, argv[i], name)) return argv[i + 1];
    }
    return null;
}
